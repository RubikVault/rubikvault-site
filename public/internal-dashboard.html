<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RubikVault Internal Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0b1120;
      color: #f8fafc;
      line-height: 1.6;
      padding: 20px;
    }
    .container { max-width: 1600px; margin: 0 auto; }
    h1 { margin-bottom: 30px; color: #38bdf8; }
    .section {
      background: #111827;
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .section h2 {
      font-size: 18px;
      margin-bottom: 15px;
      color: #38bdf8;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      padding-bottom: 10px;
    }
    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .status-card {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 8px;
      padding: 15px;
    }
    .status-card.ok { border-color: #10b981; }
    .status-card.warn { border-color: #f59e0b; }
    .status-card.fail { border-color: #ef4444; }
    .status-card h3 {
      font-size: 12px;
      text-transform: uppercase;
      color: #cbd5f5;
      margin-bottom: 8px;
    }
    .status-card .value {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    .status-card .label {
      font-size: 11px;
      color: #94a3b8;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
    }
    th {
      background: rgba(15, 23, 42, 0.6);
      font-weight: 600;
      color: #cbd5f5;
      position: sticky;
      top: 0;
      font-size: 11px;
    }
    tr:hover { background: rgba(15, 23, 42, 0.4); }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
    }
    .badge.ok { background: #10b981; color: white; }
    .badge.warn { background: #f59e0b; color: white; }
    .badge.fail { background: #ef4444; color: white; }
    .badge.partial { background: #3b82f6; color: white; }
    .badge.stale { background: #8b5cf6; color: white; }
    .refresh-btn {
      background: #38bdf8;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      margin-bottom: 15px;
    }
    .refresh-btn:hover { background: #0ea5e9; }
    .timestamp {
      font-size: 11px;
      color: #94a3b8;
      margin-top: 10px;
    }
    .loading { opacity: 0.5; pointer-events: none; }
    .reason-text {
      font-size: 11px;
      color: #94a3b8;
      font-style: italic;
    }
    .age-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      background: rgba(148, 163, 184, 0.2);
    }
    .age-badge.fresh { background: #10b981; color: white; }
    .age-badge.stale { background: #f59e0b; color: white; }
    .age-badge.expired { background: #ef4444; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîç RubikVault Internal Dashboard <span id="rv-internal-auth" class="badge warn">auth: unknown</span></h1>

    <div class="section">
      <h2>System Health Overview</h2>
      <button class="refresh-btn" onclick="refreshAll()">üîÑ Refresh All</button>
      <div class="status-grid" id="health-overview">
        <div class="status-card">
          <h3>Overall Status</h3>
          <div class="value">‚Äî</div>
          <div class="label">Loading...</div>
        </div>
      </div>
      <div class="timestamp" id="health-timestamp"></div>
    </div>

    <div class="section">
      <h2>Active Blocks Status (8 Blocks)</h2>
      <div style="overflow-x: auto;">
        <table id="block-matrix">
          <thead>
            <tr>
              <th>Block</th>
              <th>Status</th>
              <th>Data Present</th>
              <th>Items Count</th>
              <th>Age</th>
              <th>Freshness</th>
              <th>Reason / Issue</th>
              <th>Last Updated</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="8">Loading...</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="section">
      <h2>API Key Usage & Limits</h2>
      <table id="api-keys">
        <thead>
          <tr>
            <th>Provider</th>
            <th>Status</th>
            <th>Used Today</th>
            <th>Limit (Day)</th>
            <th>Remaining (Day)</th>
            <th>% Used (Day)</th>
            <th>Used (Month)</th>
            <th>Limit (Month)</th>
            <th>Remaining (Month)</th>
            <th>% Used (Month)</th>
            <th>Last Error</th>
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="11">Loading...</td></tr>
        </tbody>
      </table>
    </div>

    <div class="section">
      <h2>Cloudflare Workers Usage</h2>
      <div class="status-grid" id="workers-usage">
        <div class="status-card">
          <h3>Workers Requests</h3>
          <div class="value">‚Äî</div>
          <div class="label">Loading...</div>
        </div>
      </div>
      <div class="timestamp" id="workers-timestamp"></div>
    </div>

    <div class="section">
      <h2>Endpoint Reachability</h2>
      <div style="overflow-x: auto;">
        <table id="endpoint-probes">
          <thead>
            <tr>
              <th>Endpoint</th>
              <th>Status</th>
              <th>Hint</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="3">Loading...</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script type="module">
    // ACTIVE BLOCKS ONLY (8 blocks on the website)
    // These match the data-rv-feature attributes in index.html
    const ACTIVE_BLOCKS = [
      { id: 'rv-market-cockpit', name: 'Market Snapshot (Global Macro Hub)', snapshotPath: '/data/snapshots/macro-hub.json' },
      { id: 'rv-news-headlines', name: 'News Headlines', snapshotPath: '/data/snapshots/news-headlines.json' },
      { id: 'rv-sp500-sectors', name: 'S&P 500 Sectors', snapshotPath: '/data/snapshots/sp500-sectors.json' },
      { id: 'rv-tech-signals', name: 'Tech Signals', snapshotPath: '/data/snapshots/tech-signals.json' },
      { id: 'rv-rvci-engine', name: 'RVCI Engine', snapshotPath: '/data/snapshots/rvci-engine.json', altPath: '/data/rvci_latest.json' },
      { id: 'rv-alpha-radar', name: 'Alpha Radar', snapshotPath: '/data/snapshots/alpha-radar.json' },
      { id: 'rv-marketphase', name: 'MarketPhase AI', snapshotPath: '/data/marketphase/index.json', note: 'Loads individual symbol files (AAPL.json, MSFT.json, etc.)' },
      { id: 'moats', name: 'Monopoles / Economic Moats', snapshotPath: null, note: 'Static content, no snapshot' }
    ];
    
    async function fetchJSON(url) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return null;
        return await res.json();
      } catch (err) {
        console.error('Fetch error:', err);
        return null;
      }
    }

    function formatAge(minutes) {
      if (minutes < 60) return `${Math.round(minutes)}m`;
      if (minutes < 1440) return `${Math.round(minutes / 60)}h`;
      return `${Math.round(minutes / 1440)}d`;
    }

    function getAgeBadgeClass(minutes) {
      if (minutes < 60) return 'fresh';
      if (minutes < 1440) return 'stale';
      return 'expired';
    }

    function analyzeBlockData(snapshot, blockId) {
      if (!snapshot) {
        return {
          status: 'NO_DATA',
          dataPresent: false,
          itemsCount: 0,
          age: null,
          freshness: 'MISSING',
          reason: 'Snapshot file not found or failed to load',
          lastUpdated: null
        };
      }

      const meta = snapshot.meta || {};
      const data = snapshot.data || {};
      const status = meta.status || 'UNKNOWN';
      const freshness = meta.freshness || {};
      const freshnessStatus = freshness.status || 'unknown';
      const ageMinutes = freshness.ageMinutes || null;

      // Check if data is actually present
      let itemsCount = 0;
      let dataPresent = false;

      if (blockId === 'rv-market-cockpit' || blockId === 'macro-hub') {
        const metrics = data;
        const metricKeys = Object.keys(metrics).filter(k => !['debug', 'categories'].includes(k));
        itemsCount = metricKeys.length;
        const metricsWithValues = metricKeys.filter(k => {
          const m = metrics[k];
          return m && (m.value !== null && m.value !== undefined);
        }).length;
        dataPresent = metricsWithValues > 0;
      } else if (blockId === 'rv-rvci-engine' || blockId === 'rvci-engine') {
        const paths = data.paths || {};
        const counts = data.counts || {};
        itemsCount = Object.keys(paths).length;
        dataPresent = itemsCount > 0 && Object.keys(counts).length > 0;
      } else if (blockId === 'rv-alpha-radar' || blockId === 'alpha-radar') {
        const items = data.items || [];
        const picks = data.picks || data.extraData?.picks || null;
        const picksTop = picks?.top || [];
        itemsCount = items.length || picksTop.length || 0;
        dataPresent = itemsCount > 0;
        
        // Check for dummy values in picks (UI uses picks, not items)
        if (picksTop.length > 0) {
          const uniqueScores = new Set();
          picksTop.forEach(p => {
            if (p.setupScore !== undefined && p.triggerScore !== undefined && p.totalScore !== undefined) {
              uniqueScores.add(`${p.setupScore}-${p.triggerScore}-${p.totalScore}`);
            }
          });
          // If all picks have identical scores, it's likely dummy data
          if (uniqueScores.size === 1 && picksTop.length > 1) {
            const firstPick = picksTop[0];
            return {
              status: 'DUMMY_DATA',
              dataPresent: true,
              itemsCount,
              age: ageMinutes,
              freshness: freshnessStatus,
              reason: `All picks have identical dummy values (Setup ${firstPick.setupScore}, Trigger ${firstPick.triggerScore}, Total ${firstPick.totalScore}). Data is ${ageMinutes ? formatAge(ageMinutes) : 'unknown'} old. Snapshot picks may not be updating correctly.`,
              lastUpdated: meta.generatedAt || meta.updatedAt
            };
          }
        }
        
        // Also check items for old dummy pattern
        if (items.length > 0) {
          const firstItem = items[0];
          if (firstItem.setupScore === 34 && firstItem.triggerScore === 51 && firstItem.totalScore === 85) {
            return {
              status: 'DUMMY_DATA',
              dataPresent: true,
              itemsCount,
              age: ageMinutes,
              freshness: freshnessStatus,
              reason: `Data contains dummy values (Setup 34, Trigger 51, Total 85). Data is ${ageMinutes ? formatAge(ageMinutes) : 'unknown'} old. Snapshot may not be updating correctly.`,
              lastUpdated: meta.generatedAt || meta.updatedAt
            };
          }
        }
      } else if (blockId === 'rv-sp500-sectors' || blockId === 'sp500-sectors') {
        const items = data.items || [];
        const sectors = data.sectors || [];
        itemsCount = items.length || sectors.length;
        dataPresent = itemsCount > 0 || sectors.length > 0;
        
        // Check if data structure matches UI expectations
        if (sectors.length > 0) {
          const firstSector = sectors[0];
          // UI expects: rel.r1w, rel.r1d, rel.r1m, relTech.rsi, etc.
          // Snapshot has: changePercent, relativeToSpy, price, symbol, name
          const hasRelFields = firstSector.rel && (firstSector.rel.r1w !== undefined || firstSector.rel.r1d !== undefined);
          const hasRelTechFields = firstSector.relTech && firstSector.relTech.rsi !== undefined;
          const hasOldFields = firstSector.changePercent !== undefined && firstSector.relativeToSpy !== undefined;
          
          // If we have old structure (changePercent) but not new structure (rel.r1w), UI won't render correctly
          if (hasOldFields && !hasRelFields && !hasRelTechFields) {
            return {
              status: 'INVALID_DATA_STRUCTURE',
              dataPresent: true,
              itemsCount,
              age: ageMinutes,
              freshness: freshnessStatus,
              reason: `Data structure mismatch: Snapshot has ${itemsCount} sectors with old structure (changePercent, relativeToSpy) but UI expects new structure (rel.r1w, relTech.rsi). UI cannot render this data. Check build-snapshots.mjs mapping for sp500-sectors.`,
              lastUpdated: meta.generatedAt || meta.updatedAt
            };
          }
        }
        
        if (itemsCount === 0 && sectors.length === 0) {
          return {
            status: 'EMPTY_ITEMS',
            dataPresent: false,
            itemsCount: 0,
            age: ageMinutes,
            freshness: freshnessStatus,
            reason: 'No sectors or items found in snapshot. Mirror may be empty or not generating correctly.',
            lastUpdated: meta.generatedAt || meta.updatedAt
          };
        }
      } else if (blockId === 'rv-tech-signals' || blockId === 'tech-signals') {
        const items = data.items || [];
        itemsCount = items.length;
        dataPresent = itemsCount > 0;
        // Check if items have actual signal data
        if (itemsCount > 0) {
          const firstItem = items[0];
          const hasSignals = firstItem.rsi !== undefined || firstItem.macd !== undefined || firstItem.rsiWeekly !== undefined;
          if (!hasSignals) {
            return {
              status: 'INVALID_DATA',
              dataPresent: false,
              itemsCount,
              age: ageMinutes,
              freshness: freshnessStatus,
              reason: 'Items exist but lack signal data (RSI, MACD, etc.). Snapshot may be incomplete.',
              lastUpdated: meta.generatedAt || meta.updatedAt
            };
          }
        }
      } else if (blockId === 'rv-marketphase' || blockId === 'marketphase') {
        // MarketPhase loads individual symbol files, check index.json
        const symbols = data.symbols || [];
        itemsCount = symbols.length;
        dataPresent = symbols.length > 0;
        if (symbols.length === 0) {
          return {
            status: 'NO_SYMBOLS',
            dataPresent: false,
            itemsCount: 0,
            age: ageMinutes,
            freshness: freshnessStatus,
            reason: 'No symbols found in index.json. MarketPhase files may not be generated.',
            lastUpdated: meta.generatedAt || meta.updatedAt
          };
        }
      } else {
        const items = data.items || [];
        itemsCount = items.length;
        dataPresent = itemsCount > 0;
      }

      let reason = meta.reason || status;
      if (status === 'PARTIAL' && itemsCount === 0) {
        reason = 'EMPTY_ITEMS - No data items in snapshot';
      } else if (status === 'DEGRADED_COVERAGE') {
        reason = `DEGRADED_COVERAGE - ${meta.universe ? `Expected ${meta.universe.expected}, got ${meta.universe.received}` : 'Coverage below threshold'}`;
      } else if (ageMinutes && ageMinutes > 1440) {
        reason = `Data is ${formatAge(ageMinutes)} old (${Math.round(ageMinutes / 1440)} days). Last update: ${meta.generatedAt || meta.updatedAt || 'unknown'}`;
      } else if (status === 'OK' && !dataPresent) {
        reason = 'OK status but no data present - snapshot may be empty or invalid';
      }

      return {
        status,
        dataPresent,
        itemsCount,
        age: ageMinutes,
        freshness: freshnessStatus,
        reason,
        lastUpdated: meta.generatedAt || meta.updatedAt || meta.dataAt
      };
    }

    async function updateHealthOverview() {
      const systemHealth = await fetchJSON('/data/system-health.json');
      const container = document.getElementById('health-overview');
      
      if (!systemHealth) {
        container.innerHTML = '<div class="status-card fail"><h3>Error</h3><div class="value">Failed</div><div class="label">Cannot fetch system-health.json</div></div>';
        return;
      }

      const buildStatus = systemHealth.buildStatus || 'UNKNOWN';
      const summary = systemHealth.summary || {};
      const statusClass = buildStatus === 'OK' ? 'ok' : buildStatus === 'WARN' ? 'warn' : 'fail';
      
      container.innerHTML = `
        <div class="status-card ${statusClass}">
          <h3>Build Status</h3>
          <div class="value">${buildStatus}</div>
          <div class="label">${systemHealth.reasons?.length ? systemHealth.reasons.join(', ') : 'Static snapshot pipeline'}</div>
        </div>
        <div class="status-card">
          <h3>Blocks OK</h3>
          <div class="value">${summary.ok || 0}</div>
          <div class="label">of ${summary.total || 0} total</div>
        </div>
        <div class="status-card">
          <h3>Blocks Failed</h3>
          <div class="value">${summary.fail || 0}</div>
          <div class="label">Requires attention</div>
        </div>
        <div class="status-card">
          <h3>Last Build</h3>
          <div class="value">${systemHealth.generatedAt ? new Date(systemHealth.generatedAt).toLocaleDateString() : '‚Äî'}</div>
          <div class="label">${systemHealth.generatedAt ? new Date(systemHealth.generatedAt).toLocaleTimeString() : '‚Äî'}</div>
        </div>
      `;
      
      document.getElementById('health-timestamp').textContent = `Last updated: ${new Date().toLocaleString()}`;
    }

    async function updateBlockMatrix() {
      const tbody = document.querySelector('#block-matrix tbody');
      if (!tbody) return;

      const results = await Promise.all(ACTIVE_BLOCKS.map(async (block) => {
        if (!block.snapshotPath) {
          return {
            block: block.name,
            status: 'STATIC',
            dataPresent: true,
            itemsCount: 'N/A',
            age: null,
            freshness: 'STATIC',
            reason: block.note || 'Static content, no snapshot required',
            lastUpdated: 'N/A'
          };
        }

        let snapshot = await fetchJSON(block.snapshotPath);
        if (!snapshot && block.altPath) {
          snapshot = await fetchJSON(block.altPath);
        }

        const analysis = analyzeBlockData(snapshot, block.id);
        return {
          block: block.name,
          ...analysis
        };
      }));

      tbody.innerHTML = results.map(result => {
        // Determine status class based on actual data quality
        let statusClass = 'ok';
        if (result.status === 'DUMMY_DATA' || result.status === 'NO_DATA' || result.status === 'EMPTY_ITEMS' || result.status === 'INVALID_DATA' || result.status === 'INVALID_DATA_STRUCTURE' || result.status === 'NO_SYMBOLS') {
          statusClass = 'fail';
        } else if (result.status === 'PARTIAL' || !result.dataPresent) {
          statusClass = 'warn';
        } else if (result.status === 'OK' && !result.dataPresent) {
          statusClass = 'fail';
        } else if (result.age && result.age > 1440) {
          statusClass = 'warn';
        } else if (result.status === 'STATIC') {
          statusClass = 'ok';
        }
        
        const ageDisplay = result.age !== null ? formatAge(result.age) : '‚Äî';
        const ageBadgeClass = result.age !== null ? getAgeBadgeClass(result.age) : '';
        
        return `
          <tr>
            <td><strong>${result.block}</strong></td>
            <td><span class="badge ${statusClass}">${result.status}</span></td>
            <td>${result.dataPresent ? '‚úÖ' : '‚ùå'}</td>
            <td>${result.itemsCount}</td>
            <td>${result.age !== null ? `<span class="age-badge ${ageBadgeClass}">${ageDisplay}</span>` : '‚Äî'}</td>
            <td><span class="badge ${result.freshness === 'fresh' ? 'ok' : result.freshness === 'stale' ? 'warn' : 'fail'}">${result.freshness.toUpperCase()}</span></td>
            <td><span class="reason-text">${result.reason}</span></td>
            <td>${result.lastUpdated ? new Date(result.lastUpdated).toLocaleString() : '‚Äî'}</td>
          </tr>
        `;
      }).join('');
    }

    async function updateApiKeys() {
      const usageReport = await fetchJSON('/data/usage-report.json');
      const providerState = await fetchJSON('/data/provider-state.json');
      const macroHub = await fetchJSON('/data/snapshots/macro-hub.json');
      const tbody = document.querySelector('#api-keys tbody');
      
      if (!usageReport || !usageReport.providers) {
        tbody.innerHTML = '<tr><td colspan="11">No API usage data available</td></tr>';
        return;
      }

      const providers = usageReport.providers || {};
      const macroHubCalls = macroHub?.meta?.providerCalls || {};
      const macroHubErrors = macroHub?.meta?.errors || [];

      // Build error map
      const errorMap = {};
      macroHubErrors.forEach(err => {
        const provider = err.provider || 'UNKNOWN';
        if (!errorMap[provider]) errorMap[provider] = [];
        errorMap[provider].push(err.message || err.code || 'ERROR');
      });

      const rows = Object.entries(providers).map(([provider, data]) => {
        const daily = data.daily || {};
        const monthly = data.monthly || {};
        const usedToday = daily.used || 0;
        const limitToday = daily.limit || 0;
        const remainingToday = daily.remaining || 0;
        const pctToday = limitToday > 0 ? ((usedToday / limitToday) * 100).toFixed(1) : '0.0';
        const usedMonth = monthly.used || 0;
        const limitMonth = monthly.limit || 0;
        const remainingMonth = monthly.remaining || 0;
        const pctMonth = limitMonth > 0 ? ((usedMonth / limitMonth) * 100).toFixed(1) : '0.0';
        
        const statusClass = data.status === 'green' ? 'ok' : data.status === 'yellow' ? 'warn' : 'fail';
        const pctTodayClass = parseFloat(pctToday) > 95 ? 'fail' : parseFloat(pctToday) > 80 ? 'warn' : 'ok';
        const pctMonthClass = parseFloat(pctMonth) > 95 ? 'fail' : parseFloat(pctMonth) > 80 ? 'warn' : 'ok';
        
        const lastError = errorMap[provider] ? errorMap[provider][errorMap[provider].length - 1] : '‚Äî';
        const callsFromMacroHub = macroHubCalls[provider] || 0;

        return `
          <tr>
            <td><strong>${provider}</strong></td>
            <td><span class="badge ${statusClass}">${data.status || 'UNKNOWN'}</span></td>
            <td>${usedToday + callsFromMacroHub}</td>
            <td>${limitToday}</td>
            <td>${remainingToday - callsFromMacroHub}</td>
            <td><span class="badge ${pctTodayClass}">${pctToday}%</span></td>
            <td>${usedMonth + callsFromMacroHub}</td>
            <td>${limitMonth}</td>
            <td>${remainingMonth - callsFromMacroHub}</td>
            <td><span class="badge ${pctMonthClass}">${pctMonth}%</span></td>
            <td><code style="font-size: 10px;">${lastError}</code></td>
          </tr>
        `;
      }).join('');

      tbody.innerHTML = rows || '<tr><td colspan="11">No provider data</td></tr>';
    }

    async function updateWorkersUsage() {
      const container = document.getElementById('workers-usage');
      // Cloudflare Workers usage is not directly tracked in static files
      // We can show estimated usage based on system-health or leave as placeholder
      container.innerHTML = `
        <div class="status-card">
          <h3>Workers Requests (Daily)</h3>
          <div class="value">‚Äî</div>
          <div class="label">Not tracked in static files</div>
        </div>
        <div class="status-card">
          <h3>Workers CPU Time</h3>
          <div class="value">‚Äî</div>
          <div class="label">Check Cloudflare Dashboard</div>
        </div>
        <div class="status-card">
          <h3>Note</h3>
          <div class="value" style="font-size: 14px;">Static-First</div>
          <div class="label">All data served from CDN (public/data/*)</div>
        </div>
      `;
      document.getElementById('workers-timestamp').textContent = `Workers usage should be monitored via Cloudflare Dashboard. Static-first architecture minimizes Workers usage.`;
    }

    async function updateEndpointProbes() {
      const tbody = document.querySelector('#endpoint-probes tbody');
      if (!tbody) return;

      const targets = [
        { path: '/data/system-health.json', hint: 'Static build health snapshot' },
        { path: '/data/provider-state.json', hint: 'Circuit + lock state' },
        { path: '/data/usage-report.json', hint: 'Budget usage and remaining' },
        { path: '/data/snapshots/macro-hub.json', hint: 'Macro hub snapshot' },
        { path: '/data/snapshots/alpha-radar.json', hint: 'Alpha radar snapshot' },
        { path: '/data/snapshots/rvci-engine.json', hint: 'RVCI engine snapshot' }
      ];

      const results = await Promise.all(targets.map(async (t) => {
        try {
          const res = await fetch(t.path, { method: 'HEAD', cache: 'no-store' });
          return { ...t, ok: res.ok, status: res.status };
        } catch (err) {
          return { ...t, ok: false, status: 0 };
        }
      }));

      tbody.innerHTML = results.map((row) => {
        const statusClass = row.ok ? 'ok' : row.status === 404 ? 'warn' : 'fail';
        const label = row.ok ? `OK (${row.status})` : row.status ? `FAIL (${row.status})` : 'FAIL (network)';
        return `
          <tr>
            <td><code>${row.path}</code></td>
            <td><span class="badge ${statusClass}">${label}</span></td>
            <td>${row.hint}</td>
          </tr>
        `;
      }).join('');
    }

    async function refreshAll() {
      document.body.classList.add('loading');
      await Promise.all([
        updateHealthOverview(),
        updateBlockMatrix(),
        updateApiKeys(),
        updateWorkersUsage(),
        updateEndpointProbes()
      ]);
      document.body.classList.remove('loading');
    }

    // Auto-refresh every 30 seconds
    refreshAll();
    setInterval(refreshAll, 30000);
  </script>
</body>
</html>
